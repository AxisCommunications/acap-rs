/* automatically generated by rust-bindgen 0.69.5 */

pub const axoverlay_error_code_AXOVERLAY_ERROR_INVALID_VALUE: axoverlay_error_code = 1000;
pub const axoverlay_error_code_AXOVERLAY_ERROR_INTERNAL: axoverlay_error_code = 2000;
pub const axoverlay_error_code_AXOVERLAY_ERROR_UNEXPECTED: axoverlay_error_code = 3000;
pub const axoverlay_error_code_AXOVERLAY_ERROR_GENERIC: axoverlay_error_code = 4000;
pub const axoverlay_error_code_AXOVERLAY_ERROR_INVALID_ARGUMENT: axoverlay_error_code = 5000;
pub const axoverlay_error_code_AXOVERLAY_ERROR_SERVICE_UNAVAILABLE: axoverlay_error_code = 6000;
pub const axoverlay_error_code_AXOVERLAY_ERROR_BACKEND: axoverlay_error_code = 7000;
pub type axoverlay_error_code = ::std::os::raw::c_uint;
pub const axoverlay_colorspace_AXOVERLAY_COLORSPACE_ARGB32: axoverlay_colorspace = 0;
pub const axoverlay_colorspace_AXOVERLAY_COLORSPACE_4BIT_PALETTE: axoverlay_colorspace = 1;
pub const axoverlay_colorspace_AXOVERLAY_COLORSPACE_1BIT_PALETTE: axoverlay_colorspace = 2;
pub const axoverlay_colorspace_AXOVERLAY_COLORSPACE_UNDEFINED: axoverlay_colorspace = 3;
pub type axoverlay_colorspace = ::std::os::raw::c_uint;
pub const axoverlay_position_type_AXOVERLAY_TOP_LEFT: axoverlay_position_type = 0;
pub const axoverlay_position_type_AXOVERLAY_TOP_RIGHT: axoverlay_position_type = 1;
pub const axoverlay_position_type_AXOVERLAY_BOTTOM_LEFT: axoverlay_position_type = 2;
pub const axoverlay_position_type_AXOVERLAY_BOTTOM_RIGHT: axoverlay_position_type = 3;
pub const axoverlay_position_type_AXOVERLAY_CUSTOM_NORMALIZED: axoverlay_position_type = 4;
pub const axoverlay_position_type_AXOVERLAY_CUSTOM_SOURCE: axoverlay_position_type = 5;
pub type axoverlay_position_type = ::std::os::raw::c_uint;
pub const axoverlay_backend_type_AXOVERLAY_CAIRO_IMAGE_BACKEND: axoverlay_backend_type = 1;
pub const axoverlay_backend_type_AXOVERLAY_OPENGLES_BACKEND: axoverlay_backend_type = 2;
pub const axoverlay_backend_type_AXOVERLAY_OPEN_BACKEND: axoverlay_backend_type = 3;
pub type axoverlay_backend_type = ::std::os::raw::c_uint;
pub const axoverlay_anchor_point_AXOVERLAY_ANCHOR_TOP_LEFT: axoverlay_anchor_point = 0;
pub const axoverlay_anchor_point_AXOVERLAY_ANCHOR_CENTER: axoverlay_anchor_point = 1;
pub type axoverlay_anchor_point = ::std::os::raw::c_uint;
pub const axoverlay_stream_type_AXOVERLAY_STREAM_JPEG: axoverlay_stream_type = 0;
pub const axoverlay_stream_type_AXOVERLAY_STREAM_H264: axoverlay_stream_type = 1;
pub const axoverlay_stream_type_AXOVERLAY_STREAM_H265: axoverlay_stream_type = 2;
pub const axoverlay_stream_type_AXOVERLAY_STREAM_YCBCR: axoverlay_stream_type = 3;
pub const axoverlay_stream_type_AXOVERLAY_STREAM_VOUT: axoverlay_stream_type = 4;
pub const axoverlay_stream_type_AXOVERLAY_STREAM_OTHER: axoverlay_stream_type = 5;
pub const axoverlay_stream_type_AXOVERLAY_STREAM_RGB: axoverlay_stream_type = 6;
pub const axoverlay_stream_type_AXOVERLAY_STREAM_AV1: axoverlay_stream_type = 7;
pub type axoverlay_stream_type = ::std::os::raw::c_uint;
#[repr(C)]
pub struct axoverlay_stream_data {
    pub id: gint,
    pub camera: gint,
    pub width: gint,
    pub height: gint,
    pub rotation: gint,
    pub is_mirrored: gboolean,
    pub type_: axoverlay_stream_type,
}
#[repr(C)]
pub struct axoverlay_overlay_data {
    pub anchor_point: axoverlay_anchor_point,
    pub postype: axoverlay_position_type,
    pub x: gfloat,
    pub y: gfloat,
    pub width: gint,
    pub height: gint,
    pub z_priority: gint,
    pub colorspace: axoverlay_colorspace,
    pub scale_to_stream: gboolean,
}
#[repr(C)]
pub struct axoverlay_palette_color {
    pub red: guchar,
    pub green: guchar,
    pub blue: guchar,
    pub alpha: guchar,
    pub pixelate: gboolean,
}
pub type axoverlay_stream_select_function = ::std::option::Option<
    unsafe extern "C" fn(
        camera: gint,
        width: gint,
        height: gint,
        rotation: gint,
        is_mirrored: gboolean,
        type_: axoverlay_stream_type,
    ) -> gboolean,
>;
pub type axoverlay_adjustment_function = ::std::option::Option<
    unsafe extern "C" fn(
        id: gint,
        stream: *mut axoverlay_stream_data,
        postype: *mut axoverlay_position_type,
        overlay_x: *mut gfloat,
        overlay_y: *mut gfloat,
        overlay_width: *mut gint,
        overlay_height: *mut gint,
        user_data: gpointer,
    ),
>;
pub type axoverlay_render_function = ::std::option::Option<
    unsafe extern "C" fn(
        rendering_context: gpointer,
        id: gint,
        stream: *mut axoverlay_stream_data,
        postype: axoverlay_position_type,
        overlay_x: gfloat,
        overlay_y: gfloat,
        overlay_width: gint,
        overlay_height: gint,
        user_data: gpointer,
    ),
>;
pub type axoverlay_synced_render_function = ::std::option::Option<
    unsafe extern "C" fn(
        rendering_context: gpointer,
        id: gint,
        stream: *mut axoverlay_stream_data,
        postype: axoverlay_position_type,
        overlay_x: gfloat,
        overlay_y: gfloat,
        overlay_width: gint,
        overlay_height: gint,
        timestamp: *mut timeval,
        user_data: gpointer,
    ),
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct axoverlay_settings {
    pub render_callback: axoverlay_render_function,
    pub adjustment_callback: axoverlay_adjustment_function,
    pub select_callback: axoverlay_stream_select_function,
    pub backend: axoverlay_backend_type,
}
extern "C" {
    pub fn axoverlay_enable_cpu_mem_sync(sync: gboolean);
}
extern "C" {
    pub fn axoverlay_set_adjustment_callback(adjustment_callback: axoverlay_adjustment_function);
}
extern "C" {
    pub fn axoverlay_set_stream_select_callback(select_callback: axoverlay_stream_select_function);
}
extern "C" {
    pub fn axoverlay_set_render_callback(render_callback: axoverlay_render_function);
}
extern "C" {
    pub fn axoverlay_set_synced_render_callback(render_callback: axoverlay_synced_render_function);
}
extern "C" {
    pub fn axoverlay_set_backend(backend: *const ::std::os::raw::c_char);
}
extern "C" {
    pub fn axoverlay_init_axoverlay_settings(axoverlay_settings: *mut axoverlay_settings);
}
extern "C" {
    pub fn axoverlay_init(axoverlay_settings: *mut axoverlay_settings, error: *mut *mut GError);
}
extern "C" {
    pub fn axoverlay_cleanup();
}
extern "C" {
    pub fn axoverlay_reload_streams(error: *mut *mut GError);
}
extern "C" {
    pub fn axoverlay_redraw(error: *mut *mut GError);
}
extern "C" {
    pub fn axoverlay_init_overlay_data(data: *mut axoverlay_overlay_data);
}
extern "C" {
    pub fn axoverlay_create_overlay(
        data: *mut axoverlay_overlay_data,
        user_data: gpointer,
        error: *mut *mut GError,
    ) -> gint;
}
extern "C" {
    pub fn axoverlay_destroy_overlay(id: gint, error: *mut *mut GError);
}
extern "C" {
    pub fn axoverlay_set_overlay_position(
        id: gint,
        postype: axoverlay_position_type,
        x: gfloat,
        y: gfloat,
        error: *mut *mut GError,
    );
}
extern "C" {
    pub fn axoverlay_set_overlay_size(id: gint, width: gint, height: gint, error: *mut *mut GError);
}
extern "C" {
    pub fn axoverlay_get_max_resolution_width(camera: gint, error: *mut *mut GError) -> gint;
}
extern "C" {
    pub fn axoverlay_get_max_resolution_height(camera: gint, error: *mut *mut GError) -> gint;
}
extern "C" {
    pub fn axoverlay_is_backend_supported(backend: axoverlay_backend_type) -> gboolean;
}
extern "C" {
    pub fn axoverlay_get_number_of_palette_colors(error: *mut *mut GError) -> gint;
}
extern "C" {
    pub fn axoverlay_get_palette_color(
        index: gint,
        color: *mut axoverlay_palette_color,
        error: *mut *mut GError,
    );
}
extern "C" {
    pub fn axoverlay_set_palette_color(
        index: gint,
        color: *mut axoverlay_palette_color,
        error: *mut *mut GError,
    );
}
