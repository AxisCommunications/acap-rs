/* automatically generated by rust-bindgen 0.69.5 */

#[repr(C)]
#[derive(Default)]
pub struct __IncompleteArrayField<T>(::std::marker::PhantomData<T>, [T; 0]);
impl<T> __IncompleteArrayField<T> {
    #[inline]
    pub const fn new() -> Self {
        __IncompleteArrayField(::std::marker::PhantomData, [])
    }
    #[inline]
    pub fn as_ptr(&self) -> *const T {
        self as *const _ as *const T
    }
    #[inline]
    pub fn as_mut_ptr(&mut self) -> *mut T {
        self as *mut _ as *mut T
    }
    #[inline]
    pub unsafe fn as_slice(&self, len: usize) -> &[T] {
        ::std::slice::from_raw_parts(self.as_ptr(), len)
    }
    #[inline]
    pub unsafe fn as_mut_slice(&mut self, len: usize) -> &mut [T] {
        ::std::slice::from_raw_parts_mut(self.as_mut_ptr(), len)
    }
}
impl<T> ::std::fmt::Debug for __IncompleteArrayField<T> {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        fmt.write_str("__IncompleteArrayField")
    }
}
#[repr(C)]
pub struct __BindgenUnionField<T>(::std::marker::PhantomData<T>);
impl<T> __BindgenUnionField<T> {
    #[inline]
    pub const fn new() -> Self {
        __BindgenUnionField(::std::marker::PhantomData)
    }
    #[inline]
    pub unsafe fn as_ref(&self) -> &T {
        ::std::mem::transmute(self)
    }
    #[inline]
    pub unsafe fn as_mut(&mut self) -> &mut T {
        ::std::mem::transmute(self)
    }
}
impl<T> ::std::default::Default for __BindgenUnionField<T> {
    #[inline]
    fn default() -> Self {
        Self::new()
    }
}
impl<T> ::std::clone::Clone for __BindgenUnionField<T> {
    #[inline]
    fn clone(&self) -> Self {
        *self
    }
}
impl<T> ::std::marker::Copy for __BindgenUnionField<T> {}
impl<T> ::std::fmt::Debug for __BindgenUnionField<T> {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        fmt.write_str("__BindgenUnionField")
    }
}
impl<T> ::std::hash::Hash for __BindgenUnionField<T> {
    fn hash<H: ::std::hash::Hasher>(&self, _state: &mut H) {}
}
impl<T> ::std::cmp::PartialEq for __BindgenUnionField<T> {
    fn eq(&self, _other: &__BindgenUnionField<T>) -> bool {
        true
    }
}
impl<T> ::std::cmp::Eq for __BindgenUnionField<T> {}
#[repr(i32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum VdoWdrMode {
    VDO_WDR_MODE_NONE = -1,
    VDO_WDR_MODE_LINEAR = 0,
    VDO_WDR_MODE_2X = 1,
    VDO_WDR_MODE_3X = 2,
    VDO_WDR_MODE_4X = 3,
    VDO_WDR_MODE_SENSOR = 4,
    VDO_WDR_MODE_OFF = 5,
}
#[repr(i32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum VdoFormat {
    VDO_FORMAT_NONE = -1,
    VDO_FORMAT_H264 = 0,
    VDO_FORMAT_H265 = 1,
    VDO_FORMAT_JPEG = 2,
    VDO_FORMAT_YUV = 3,
    VDO_FORMAT_BAYER = 4,
    VDO_FORMAT_IVS = 5,
    VDO_FORMAT_RAW = 6,
    VDO_FORMAT_RGBA = 7,
    VDO_FORMAT_RGB = 8,
    VDO_FORMAT_PLANAR_RGB = 9,
    VDO_FORMAT_AV1 = 10,
}
#[repr(i32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum VdoH264Profile {
    VDO_H264_PROFILE_NONE = -1,
    VDO_H264_PROFILE_BASELINE = 0,
    VDO_H264_PROFILE_MAIN = 1,
    VDO_H264_PROFILE_HIGH = 2,
}
#[repr(i32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum VdoH265Profile {
    VDO_H265_PROFILE_NONE = -1,
    VDO_H265_PROFILE_MAIN = 0,
    VDO_H265_PROFILE_MAIN_10 = 1,
}
#[repr(i32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum VdoAV1Profile {
    VDO_AV1_PROFILE_NONE = -1,
    VDO_AV1_PROFILE_MAIN = 0,
    VDO_AV1_PROFILE_MAIN_10 = 1,
}
#[repr(i32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum VdoRateControlMode {
    VDO_RATE_CONTROL_MODE_NONE = -1,
    VDO_RATE_CONTROL_MODE_CBR = 0,
    VDO_RATE_CONTROL_MODE_VBR = 1,
    VDO_RATE_CONTROL_MODE_MBR = 2,
    VDO_RATE_CONTROL_MODE_ABR = 3,
}
#[repr(i32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum VdoRateControlPriority {
    VDO_RATE_CONTROL_PRIORITY_NONE = -1,
    VDO_RATE_CONTROL_PRIORITY_FRAMERATE = 0,
    VDO_RATE_CONTROL_PRIORITY_QUALITY = 1,
    VDO_RATE_CONTROL_PRIORITY_FULL_FRAMERATE = 2,
}
#[repr(u32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum VdoFrameType {
    VDO_FRAME_TYPE_NONE = 0,
    VDO_FRAME_TYPE_H264_SPS = 1,
    VDO_FRAME_TYPE_H264_PPS = 2,
    VDO_FRAME_TYPE_H264_SEI = 3,
    VDO_FRAME_TYPE_H264_IDR = 4,
    VDO_FRAME_TYPE_H264_I = 5,
    VDO_FRAME_TYPE_H264_P = 6,
    VDO_FRAME_TYPE_H264_B = 7,
    VDO_FRAME_TYPE_H265_SPS = 8,
    VDO_FRAME_TYPE_H265_PPS = 9,
    VDO_FRAME_TYPE_H265_VPS = 10,
    VDO_FRAME_TYPE_H265_SEI = 11,
    VDO_FRAME_TYPE_H265_IDR = 12,
    VDO_FRAME_TYPE_H265_I = 13,
    VDO_FRAME_TYPE_H265_P = 14,
    VDO_FRAME_TYPE_H265_B = 15,
    VDO_FRAME_TYPE_JPEG = 16,
    VDO_FRAME_TYPE_YUV = 17,
    VDO_FRAME_TYPE_RAW = 18,
    VDO_FRAME_TYPE_RGBA = 19,
    VDO_FRAME_TYPE_RGB = 20,
    VDO_FRAME_TYPE_PLANAR_RGB = 21,
    VDO_FRAME_TYPE_AV1_KEY = 22,
    VDO_FRAME_TYPE_AV1_INTER = 23,
    VDO_FRAME_TYPE_AV1_BIDI = 24,
}
#[repr(i32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum VdoZipStreamProfile {
    VDO_ZIPSTREAM_PROFILE_NONE = -1,
    VDO_ZIPSTREAM_PROFILE_CLASSIC = 0,
    VDO_ZIPSTREAM_PROFILE_STORAGE = 1,
    VDO_ZIPSTREAM_PROFILE_LIVE = 2,
}
#[repr(u32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum VdoChunkType {
    VDO_CHUNK_NONE = 0,
    VDO_CHUNK_ERROR = 2147483648,
}
#[repr(u32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum VdoChunkOption {
    VDO_CHUNK_OPTION_NONE = 0,
    VDO_CHUNK_OPTION_MMAP = 2147483648,
}
#[repr(C)]
pub struct VdoChunk {
    pub data: gpointer,
    pub size: gsize,
    pub type_: VdoChunkType,
    pub offset: gint64,
}
#[repr(i32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum VdoOverlayAlign {
    VDO_OVERLAY_ALIGN_NONE = -1,
    VDO_OVERLAY_ALIGN_TOP = 0,
    VDO_OVERLAY_ALIGN_BOTTOM = 1,
}
#[repr(u32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum VdoOverlayColor {
    VDO_OVERLAY_COLOR_TRANSPARENT = 0,
    VDO_OVERLAY_COLOR_BLACK = 61440,
    VDO_OVERLAY_COLOR_WHITE = 65535,
}
#[repr(u32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum VdoOverlayTextSize {
    VDO_OVERLAY_TEXT_SIZE_SMALL = 16,
    VDO_OVERLAY_TEXT_SIZE_MEDIUM = 32,
    VDO_OVERLAY_TEXT_SIZE_LARGE = 48,
}
#[repr(u32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum VdoStreamTimestamp {
    VDO_TIMESTAMP_NONE = 0,
    VDO_TIMESTAMP_UTC = 1,
    VDO_TIMESTAMP_ZIPSTREAM = 2,
    VDO_TIMESTAMP_DIFF = 4,
    VDO_TIMESTAMP_MONO_CAPTURE = 8,
    VDO_TIMESTAMP_MONO_SERVER = 16,
    VDO_TIMESTAMP_MONO_CLIENT = 32,
    VDO_TIMESTAMP_MONO_CLIENT_SERVER_DIFF = 52,
    VDO_TIMESTAMP_MONO_CLIENT_CAPTURE_DIFF = 44,
}
#[repr(u32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum VdoIntent {
    VDO_INTENT_NONE = 0,
    VDO_INTENT_CONTROL = 1,
    VDO_INTENT_MONITOR = 2,
    VDO_INTENT_CONSUME = 4,
    VDO_INTENT_PRODUCE = 8,
    VDO_INTENT_DEFAULT = 5,
    VDO_INTENT_EVENTFD = 16,
    VDO_INTENT_UNIVERSE = 4294967295,
}
#[repr(u32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum VdoStreamEvent {
    VDO_STREAM_EVENT_NONE = 0,
    VDO_STREAM_EVENT_STARTED = 1,
    VDO_STREAM_EVENT_STOPPED = 2,
    VDO_STREAM_EVENT_RESOURCE = 16,
    VDO_STREAM_EVENT_QUOTA_SOFT = 17,
    VDO_STREAM_EVENT_QUOTA_HARD = 18,
    VDO_STREAM_EVENT_ZIPSTREAM = 32,
    VDO_STREAM_EVENT_BUFFERING = 64,
    VDO_STREAM_EVENT_BUFFERING_WARN = 65,
    VDO_STREAM_EVENT_BUFFERING_FAIL = 66,
    VDO_STREAM_EVENT_CREATED = 80,
    VDO_STREAM_EVENT_CLOSED = 81,
    VDO_STREAM_EVENT_EXISTING = 82,
    VDO_STREAM_EVENT_INVALID = 4294967295,
}
#[repr(u32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum VdoBufferAccess {
    VDO_BUFFER_ACCESS_NONE = 0,
    VDO_BUFFER_ACCESS_CPU_RD = 1,
    VDO_BUFFER_ACCESS_DEV_RD = 2,
    VDO_BUFFER_ACCESS_ANY_RD = 3,
    VDO_BUFFER_ACCESS_CPU_WR = 256,
    VDO_BUFFER_ACCESS_DEV_WR = 512,
    VDO_BUFFER_ACCESS_ANY_WR = 768,
    VDO_BUFFER_ACCESS_CPU_RW = 257,
    VDO_BUFFER_ACCESS_DEV_RW = 514,
    VDO_BUFFER_ACCESS_ANY_RW = 771,
}
#[repr(u32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum VdoBufferStrategy {
    VDO_BUFFER_STRATEGY_NONE = 0,
    VDO_BUFFER_STRATEGY_INPUT = 1,
    VDO_BUFFER_STRATEGY_EXTERNAL = 2,
    VDO_BUFFER_STRATEGY_EXPLICIT = 3,
    VDO_BUFFER_STRATEGY_INFINITE = 4,
}
#[repr(C)]
pub struct VdoMemChunk {
    pub data: gpointer,
    pub data_size: gsize,
}
#[repr(C)]
pub struct VdoResolution {
    pub width: guint32,
    pub height: guint32,
}
#[repr(C)]
pub struct VdoResolutionSet {
    pub count: gsize,
    pub resolutions: __IncompleteArrayField<VdoResolution>,
}
#[repr(C)]
pub struct VdoRect {
    pub width: guint,
    pub height: guint,
    pub x: guint,
    pub y: guint,
}
#[repr(C)]
pub struct VdoPair32i {
    pub __bindgen_anon_1: __BindgenUnionField<VdoPair32i__bindgen_ty_1>,
    pub __bindgen_anon_2: __BindgenUnionField<VdoPair32i__bindgen_ty_2>,
    pub __bindgen_anon_3: __BindgenUnionField<VdoPair32i__bindgen_ty_3>,
    pub val: __BindgenUnionField<[gint32; 2usize]>,
    pub bindgen_union_field: [u32; 2usize],
}
#[repr(C)]
pub struct VdoPair32i__bindgen_ty_1 {
    pub x: gint32,
    pub y: gint32,
}
#[repr(C)]
pub struct VdoPair32i__bindgen_ty_2 {
    pub w: gint32,
    pub h: gint32,
}
#[repr(C)]
pub struct VdoPair32i__bindgen_ty_3 {
    pub num: gint32,
    pub den: gint32,
}
#[repr(C)]
pub struct VdoPair32u {
    pub __bindgen_anon_1: __BindgenUnionField<VdoPair32u__bindgen_ty_1>,
    pub __bindgen_anon_2: __BindgenUnionField<VdoPair32u__bindgen_ty_2>,
    pub __bindgen_anon_3: __BindgenUnionField<VdoPair32u__bindgen_ty_3>,
    pub res: __BindgenUnionField<VdoResolution>,
    pub val: __BindgenUnionField<[guint32; 2usize]>,
    pub bindgen_union_field: [u32; 2usize],
}
#[repr(C)]
pub struct VdoPair32u__bindgen_ty_1 {
    pub x: guint32,
    pub y: guint32,
}
#[repr(C)]
pub struct VdoPair32u__bindgen_ty_2 {
    pub w: guint32,
    pub h: guint32,
}
#[repr(C)]
pub struct VdoPair32u__bindgen_ty_3 {
    pub num: guint32,
    pub den: guint32,
}
extern "C" {
    pub fn vdo_wdr_mode_get_type() -> GType;
}
extern "C" {
    pub fn vdo_format_get_type() -> GType;
}
extern "C" {
    pub fn vdo_h264_profile_get_type() -> GType;
}
extern "C" {
    pub fn vdo_h265_profile_get_type() -> GType;
}
extern "C" {
    pub fn vdo_av1_profile_get_type() -> GType;
}
extern "C" {
    pub fn vdo_zipstream_profile_get_type() -> GType;
}
extern "C" {
    pub fn vdo_rate_control_mode_get_type() -> GType;
}
extern "C" {
    pub fn vdo_rate_control_priority_get_type() -> GType;
}
extern "C" {
    pub fn vdo_frame_type_get_type() -> GType;
}
extern "C" {
    pub fn vdo_color_get_type() -> GType;
}
extern "C" {
    pub fn vdo_timestamp_get_type() -> GType;
}
extern "C" {
    pub fn vdo_intent_get_type() -> GType;
}
extern "C" {
    pub fn vdo_buffer_access_get_type() -> GType;
}
extern "C" {
    pub fn vdo_buffer_strategy_get_type() -> GType;
}
extern "C" {
    pub fn vdo_format_to_str(format: VdoFormat) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn vdo_map_get_type() -> GType;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _VdoMap {
    _unused: [u8; 0],
}
pub type VdoMap = _VdoMap;
#[repr(C)]
pub struct VdoMapClass {
    pub parent_class: GObjectClass,
}
pub type VdoMap_autoptr = *mut VdoMap;
pub type VdoMap_listautoptr = *mut GList;
pub type VdoMap_slistautoptr = *mut GSList;
pub type VdoMap_queueautoptr = *mut GQueue;
pub type VdoMapClass_autoptr = *mut VdoMapClass;
pub type VdoMapClass_listautoptr = *mut GList;
pub type VdoMapClass_slistautoptr = *mut GSList;
pub type VdoMapClass_queueautoptr = *mut GQueue;
extern "C" {
    pub fn vdo_map_new() -> *mut VdoMap;
}
extern "C" {
    pub fn vdo_map_new_from_variant(dictionary: *mut GVariant) -> *mut VdoMap;
}
extern "C" {
    pub fn vdo_map_empty(self_: *const VdoMap) -> gboolean;
}
extern "C" {
    pub fn vdo_map_size(self_: *const VdoMap) -> gsize;
}
extern "C" {
    pub fn vdo_map_swap(lhs: *mut VdoMap, rhs: *mut VdoMap);
}
extern "C" {
    pub fn vdo_map_contains(self_: *const VdoMap, name: *const gchar) -> gboolean;
}
extern "C" {
    pub fn vdo_map_contains_va(self_: *const VdoMap, ...) -> gboolean;
}
extern "C" {
    pub fn vdo_map_contains_strv(self_: *const VdoMap, names: *const *const gchar) -> gboolean;
}
extern "C" {
    pub fn vdo_map_entry_equals(
        self_: *const VdoMap,
        map: *const VdoMap,
        name: *const gchar,
    ) -> gboolean;
}
extern "C" {
    pub fn vdo_map_entry_updates(
        self_: *const VdoMap,
        map: *const VdoMap,
        name: *const gchar,
    ) -> gboolean;
}
extern "C" {
    pub fn vdo_map_equals(self_: *const VdoMap, map: *const VdoMap) -> gboolean;
}
extern "C" {
    pub fn vdo_map_equals_va(self_: *const VdoMap, map: *const VdoMap, ...) -> gboolean;
}
extern "C" {
    pub fn vdo_map_equals_strv(
        self_: *const VdoMap,
        map: *const VdoMap,
        names: *const *const gchar,
    ) -> gboolean;
}
extern "C" {
    pub fn vdo_map_remove(self_: *mut VdoMap, name: *const gchar);
}
extern "C" {
    pub fn vdo_map_remove_va(self_: *mut VdoMap, ...);
}
extern "C" {
    pub fn vdo_map_remove_strv(self_: *mut VdoMap, names: *const *const gchar);
}
extern "C" {
    pub fn vdo_map_clear(self_: *mut VdoMap);
}
extern "C" {
    pub fn vdo_map_filter_prefix(self_: *const VdoMap, prefix: *const gchar) -> *mut VdoMap;
}
extern "C" {
    pub fn vdo_map_filter_va(self_: *const VdoMap, ...) -> *mut VdoMap;
}
extern "C" {
    pub fn vdo_map_filter_strv(self_: *const VdoMap, names: *const *const gchar) -> *mut VdoMap;
}
extern "C" {
    pub fn vdo_map_merge(self_: *mut VdoMap, map: *const VdoMap);
}
extern "C" {
    pub fn vdo_map_copy_value(self_: *mut VdoMap, src: *const gchar, dst: *const gchar);
}
extern "C" {
    pub fn vdo_map_to_variant(self_: *const VdoMap) -> *mut GVariant;
}
extern "C" {
    pub fn vdo_map_dump(self_: *const VdoMap);
}
extern "C" {
    pub fn vdo_map_get_byte(self_: *const VdoMap, name: *const gchar, def: guchar) -> guchar;
}
extern "C" {
    pub fn vdo_map_get_int16(self_: *const VdoMap, name: *const gchar, def: gint16) -> gint16;
}
extern "C" {
    pub fn vdo_map_get_uint16(self_: *const VdoMap, name: *const gchar, def: guint16) -> guint16;
}
extern "C" {
    pub fn vdo_map_get_uint32x2(
        self_: *const VdoMap,
        name: *const gchar,
        def: *mut guint32,
    ) -> *mut guint32;
}
extern "C" {
    pub fn vdo_map_get_uint32x4(
        self_: *const VdoMap,
        name: *const gchar,
        def: *mut guint32,
    ) -> *mut guint32;
}
extern "C" {
    pub fn vdo_map_get_doublex4(
        self_: *const VdoMap,
        name: *const gchar,
        def: *mut gdouble,
    ) -> *mut gdouble;
}
extern "C" {
    pub fn vdo_map_get_variant(
        self_: *const VdoMap,
        name: *const gchar,
        def: *mut GVariant,
    ) -> *mut GVariant;
}
extern "C" {
    pub fn vdo_map_get_boolean(self_: *const VdoMap, name: *const gchar, def: gboolean)
        -> gboolean;
}
extern "C" {
    pub fn vdo_map_get_int32(self_: *const VdoMap, name: *const gchar, def: gint32) -> gint32;
}
extern "C" {
    pub fn vdo_map_get_uint32(self_: *const VdoMap, name: *const gchar, def: guint32) -> guint32;
}
extern "C" {
    pub fn vdo_map_get_int64(self_: *const VdoMap, name: *const gchar, def: gint64) -> gint64;
}
extern "C" {
    pub fn vdo_map_get_uint64(self_: *const VdoMap, name: *const gchar, def: guint64) -> guint64;
}
extern "C" {
    pub fn vdo_map_get_double(self_: *const VdoMap, name: *const gchar, def: gdouble) -> gdouble;
}
extern "C" {
    pub fn vdo_map_get_string(
        self_: *const VdoMap,
        name: *const gchar,
        size: *mut gsize,
        def: *const gchar,
    ) -> *const gchar;
}
extern "C" {
    pub fn vdo_map_dup_string(
        self_: *const VdoMap,
        name: *const gchar,
        def: *const gchar,
    ) -> *mut gchar;
}
extern "C" {
    pub fn vdo_map_get_pair32i(
        self_: *const VdoMap,
        name: *const gchar,
        def: VdoPair32i,
    ) -> VdoPair32i;
}
extern "C" {
    pub fn vdo_map_get_pair32u(
        self_: *const VdoMap,
        name: *const gchar,
        def: VdoPair32u,
    ) -> VdoPair32u;
}
extern "C" {
    pub fn vdo_map_set_byte(self_: *mut VdoMap, name: *const gchar, value: guchar);
}
extern "C" {
    pub fn vdo_map_set_int16(self_: *mut VdoMap, name: *const gchar, value: gint16);
}
extern "C" {
    pub fn vdo_map_set_uint16(self_: *mut VdoMap, name: *const gchar, value: guint16);
}
extern "C" {
    pub fn vdo_map_set_uint32x2(self_: *mut VdoMap, name: *const gchar, value: *const guint32);
}
extern "C" {
    pub fn vdo_map_set_uint32x4(self_: *mut VdoMap, name: *const gchar, value: *const guint32);
}
extern "C" {
    pub fn vdo_map_set_doublex4(self_: *mut VdoMap, name: *const gchar, value: *const gdouble);
}
extern "C" {
    pub fn vdo_map_set_boolean(self_: *mut VdoMap, name: *const gchar, value: gboolean);
}
extern "C" {
    pub fn vdo_map_set_int32(self_: *mut VdoMap, name: *const gchar, value: gint32);
}
extern "C" {
    pub fn vdo_map_set_uint32(self_: *mut VdoMap, name: *const gchar, value: guint32);
}
extern "C" {
    pub fn vdo_map_set_int64(self_: *mut VdoMap, name: *const gchar, value: gint64);
}
extern "C" {
    pub fn vdo_map_set_uint64(self_: *mut VdoMap, name: *const gchar, value: guint64);
}
extern "C" {
    pub fn vdo_map_set_double(self_: *mut VdoMap, name: *const gchar, value: gdouble);
}
extern "C" {
    pub fn vdo_map_set_string(self_: *mut VdoMap, name: *const gchar, value: *const gchar);
}
extern "C" {
    pub fn vdo_map_set_pair32i(self_: *mut VdoMap, name: *const gchar, value: VdoPair32i);
}
extern "C" {
    pub fn vdo_map_set_pair32u(self_: *mut VdoMap, name: *const gchar, value: VdoPair32u);
}
extern "C" {
    pub fn vdo_channel_get_type() -> GType;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _VdoChannel {
    _unused: [u8; 0],
}
pub type VdoChannel = _VdoChannel;
#[repr(C)]
pub struct VdoChannelClass {
    pub parent_class: GObjectClass,
}
pub type VdoChannel_autoptr = *mut VdoChannel;
pub type VdoChannel_listautoptr = *mut GList;
pub type VdoChannel_slistautoptr = *mut GSList;
pub type VdoChannel_queueautoptr = *mut GQueue;
pub type VdoChannelClass_autoptr = *mut VdoChannelClass;
pub type VdoChannelClass_listautoptr = *mut GList;
pub type VdoChannelClass_slistautoptr = *mut GSList;
pub type VdoChannelClass_queueautoptr = *mut GQueue;
extern "C" {
    pub fn vdo_channel_get(channel_nbr: guint, error: *mut *mut GError) -> *mut VdoChannel;
}
extern "C" {
    pub fn vdo_channel_get_ex(desc: *mut VdoMap, error: *mut *mut GError) -> *mut VdoChannel;
}
extern "C" {
    pub fn vdo_channel_get_all(error: *mut *mut GError) -> *mut GList;
}
extern "C" {
    pub fn vdo_channel_get_filtered(filter: *mut VdoMap, error: *mut *mut GError) -> *mut GList;
}
extern "C" {
    pub fn vdo_channel_get_info(self_: *mut VdoChannel, error: *mut *mut GError) -> *mut VdoMap;
}
extern "C" {
    pub fn vdo_channel_get_settings(self_: *mut VdoChannel, error: *mut *mut GError)
        -> *mut VdoMap;
}
extern "C" {
    pub fn vdo_channel_set_settings(
        self_: *mut VdoChannel,
        settings: *mut VdoMap,
        error: *mut *mut GError,
    ) -> gboolean;
}
extern "C" {
    pub fn vdo_channel_get_stream_profile(
        self_: *mut VdoChannel,
        profile: *const gchar,
        format: VdoFormat,
        error: *mut *mut GError,
    ) -> *mut VdoMap;
}
extern "C" {
    pub fn vdo_channel_get_resolutions(
        self_: *mut VdoChannel,
        filter: *mut VdoMap,
        error: *mut *mut GError,
    ) -> *mut VdoResolutionSet;
}
extern "C" {
    pub fn vdo_channel_get_id(self_: *mut VdoChannel) -> guint;
}
extern "C" {
    pub fn vdo_channel_set_stream_profile(
        self_: *mut VdoChannel,
        profile: *const gchar,
        format: VdoFormat,
        settings: *mut VdoMap,
        error: *mut *mut GError,
    ) -> gboolean;
}
extern "C" {
    pub fn vdo_channel_set_crop_dptz(
        self_: *mut VdoChannel,
        x: guint,
        y: guint,
        width: guint,
        height: guint,
        error: *mut *mut GError,
    ) -> gboolean;
}
extern "C" {
    pub fn vdo_channel_apply_alpha_blending(
        self_: *mut VdoChannel,
        fd: gint,
        error: *mut *mut GError,
    ) -> gboolean;
}
extern "C" {
    pub fn vdo_channel_set_framerate(
        self_: *mut VdoChannel,
        framerate: gdouble,
        error: *mut *mut GError,
    ) -> gboolean;
}
extern "C" {
    pub fn vdo_frame_get_type() -> GType;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _VdoFrame {
    _unused: [u8; 0],
}
pub type VdoFrame = _VdoFrame;
#[repr(C)]
pub struct VdoFrameClass {
    pub parent_class: GObjectClass,
}
pub type VdoFrame_autoptr = *mut VdoFrame;
pub type VdoFrame_listautoptr = *mut GList;
pub type VdoFrame_slistautoptr = *mut GSList;
pub type VdoFrame_queueautoptr = *mut GQueue;
pub type VdoFrameClass_autoptr = *mut VdoFrameClass;
pub type VdoFrameClass_listautoptr = *mut GList;
pub type VdoFrameClass_slistautoptr = *mut GSList;
pub type VdoFrameClass_queueautoptr = *mut GQueue;
pub type VdoFrameFinalizer = ::std::option::Option<unsafe extern "C" fn(self_: *mut VdoFrame)>;
extern "C" {
    pub fn vdo_frame_get_frame_type(self_: *mut VdoFrame) -> VdoFrameType;
}
extern "C" {
    pub fn vdo_frame_is_key(self_: *mut VdoFrame) -> gboolean;
}
extern "C" {
    pub fn vdo_frame_shown(self_: *mut VdoFrame) -> gboolean;
}
extern "C" {
    pub fn vdo_frame_get_sequence_nbr(self_: *mut VdoFrame) -> guint;
}
extern "C" {
    pub fn vdo_frame_get_timestamp(self_: *mut VdoFrame) -> guint64;
}
extern "C" {
    pub fn vdo_frame_get_custom_timestamp(self_: *mut VdoFrame) -> gint64;
}
extern "C" {
    pub fn vdo_frame_get_size(self_: *mut VdoFrame) -> gsize;
}
extern "C" {
    pub fn vdo_frame_get_header_size(self_: *mut VdoFrame) -> gssize;
}
extern "C" {
    pub fn vdo_frame_get_fd(self_: *mut VdoFrame) -> gint;
}
extern "C" {
    pub fn vdo_frame_get_extra_info(self_: *mut VdoFrame) -> *mut VdoMap;
}
extern "C" {
    pub fn vdo_frame_get_opaque(self_: *mut VdoFrame) -> gpointer;
}
extern "C" {
    pub fn vdo_frame_get_is_last_buffer(self_: *mut VdoFrame) -> gboolean;
}
extern "C" {
    pub fn vdo_frame_set_size(self_: *mut VdoFrame, size: gsize);
}
extern "C" {
    pub fn vdo_frame_set_frame_type(self_: *mut VdoFrame, type_: VdoFrameType);
}
extern "C" {
    pub fn vdo_frame_set_sequence_nbr(self_: *mut VdoFrame, seqnum: guint);
}
extern "C" {
    pub fn vdo_frame_set_timestamp(self_: *mut VdoFrame, timestamp: guint64);
}
extern "C" {
    pub fn vdo_frame_set_custom_timestamp(self_: *mut VdoFrame, timestamp: gint64);
}
extern "C" {
    pub fn vdo_frame_set_is_last_buffer(self_: *mut VdoFrame, is_last_buffer: gboolean);
}
extern "C" {
    pub fn vdo_frame_set_extra_info(self_: *mut VdoFrame, extra_info: *mut VdoMap);
}
extern "C" {
    pub fn vdo_frame_set_header_size(self_: *mut VdoFrame, size: gssize);
}
extern "C" {
    pub fn vdo_frame_memmap(self_: *mut VdoFrame) -> gpointer;
}
extern "C" {
    pub fn vdo_frame_unmap(self_: *mut VdoFrame);
}
extern "C" {
    pub fn vdo_frame_take_chunk(self_: *mut VdoFrame, error: *mut *mut GError) -> VdoChunk;
}
extern "C" {
    pub fn vdo_frame_take_chunk_ex(
        self_: *mut VdoFrame,
        options: VdoChunkOption,
        error: *mut *mut GError,
    ) -> VdoChunk;
}
pub type VdoBuffer = VdoFrame;
pub type VdoBuffer_autoptr = *mut VdoBuffer;
pub type VdoBuffer_listautoptr = *mut GList;
pub type VdoBuffer_slistautoptr = *mut GSList;
pub type VdoBuffer_queueautoptr = *mut GQueue;
pub type VdoBufferFinalizer = ::std::option::Option<unsafe extern "C" fn(self_: *mut VdoBuffer)>;
extern "C" {
    pub fn vdo_buffer_new(
        fd: gint,
        capacity: gsize,
        offset: guint64,
        opaque: gpointer,
    ) -> *mut VdoBuffer;
}
extern "C" {
    pub fn vdo_buffer_new_full(
        fd: gint,
        capacity: gsize,
        offset: guint64,
        opaque: gpointer,
        settings: *mut VdoMap,
    ) -> *mut VdoBuffer;
}
extern "C" {
    pub fn vdo_buffer_get_id(self_: *mut VdoBuffer) -> guint32;
}
extern "C" {
    pub fn vdo_buffer_get_fd(self_: *mut VdoBuffer) -> gint;
}
extern "C" {
    pub fn vdo_buffer_get_offset(self_: *mut VdoBuffer) -> gint64;
}
extern "C" {
    pub fn vdo_buffer_get_capacity(self_: *mut VdoBuffer) -> gsize;
}
extern "C" {
    pub fn vdo_buffer_is_complete(self_: *mut VdoBuffer) -> gboolean;
}
extern "C" {
    pub fn vdo_buffer_get_opaque(self_: *mut VdoBuffer) -> gpointer;
}
extern "C" {
    pub fn vdo_buffer_get_data(self_: *mut VdoBuffer) -> gpointer;
}
extern "C" {
    pub fn vdo_buffer_get_frame(self_: *mut VdoBuffer) -> *mut VdoFrame;
}
extern "C" {
    pub fn vdo_stream_get_type() -> GType;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _VdoStream {
    _unused: [u8; 0],
}
pub type VdoStream = _VdoStream;
#[repr(C)]
pub struct VdoStreamClass {
    pub parent_class: GObjectClass,
}
pub type VdoStream_autoptr = *mut VdoStream;
pub type VdoStream_listautoptr = *mut GList;
pub type VdoStream_slistautoptr = *mut GSList;
pub type VdoStream_queueautoptr = *mut GQueue;
pub type VdoStreamClass_autoptr = *mut VdoStreamClass;
pub type VdoStreamClass_listautoptr = *mut GList;
pub type VdoStreamClass_slistautoptr = *mut GSList;
pub type VdoStreamClass_queueautoptr = *mut GQueue;
extern "C" {
    pub fn vdo_stream_new(
        settings: *mut VdoMap,
        fin: VdoBufferFinalizer,
        error: *mut *mut GError,
    ) -> *mut VdoStream;
}
extern "C" {
    pub fn vdo_stream_get(id: guint, error: *mut *mut GError) -> *mut VdoStream;
}
extern "C" {
    pub fn vdo_stream_get_all(error: *mut *mut GError) -> *mut GList;
}
extern "C" {
    pub fn vdo_stream_get_id(self_: *mut VdoStream) -> guint;
}
extern "C" {
    pub fn vdo_stream_get_fd(self_: *mut VdoStream, error: *mut *mut GError) -> gint;
}
extern "C" {
    pub fn vdo_stream_get_event_fd(self_: *mut VdoStream, error: *mut *mut GError) -> gint;
}
extern "C" {
    pub fn vdo_stream_get_info(self_: *mut VdoStream, error: *mut *mut GError) -> *mut VdoMap;
}
extern "C" {
    pub fn vdo_stream_get_settings(self_: *mut VdoStream, error: *mut *mut GError) -> *mut VdoMap;
}
extern "C" {
    pub fn vdo_stream_set_settings(
        self_: *mut VdoStream,
        settings: *mut VdoMap,
        error: *mut *mut GError,
    ) -> gboolean;
}
extern "C" {
    pub fn vdo_stream_set_framerate(
        self_: *mut VdoStream,
        framerate: gdouble,
        error: *mut *mut GError,
    ) -> gboolean;
}
extern "C" {
    pub fn vdo_stream_attach(
        self_: *mut VdoStream,
        intent: *mut VdoMap,
        error: *mut *mut GError,
    ) -> gboolean;
}
extern "C" {
    pub fn vdo_stream_start(self_: *mut VdoStream, error: *mut *mut GError) -> gboolean;
}
extern "C" {
    pub fn vdo_stream_play(
        self_: *mut VdoStream,
        settings: *mut VdoMap,
        error: *mut *mut GError,
    ) -> gboolean;
}
extern "C" {
    pub fn vdo_stream_stop(self_: *mut VdoStream);
}
extern "C" {
    pub fn vdo_stream_force_key_frame(self_: *mut VdoStream, error: *mut *mut GError) -> gboolean;
}
extern "C" {
    pub fn vdo_stream_buffer_alloc(
        self_: *mut VdoStream,
        opaque: gpointer,
        error: *mut *mut GError,
    ) -> *mut VdoBuffer;
}
extern "C" {
    pub fn vdo_stream_buffer_unref(
        self_: *mut VdoStream,
        buffer: *mut *mut VdoBuffer,
        error: *mut *mut GError,
    ) -> gboolean;
}
extern "C" {
    pub fn vdo_stream_buffer_enqueue(
        self_: *mut VdoStream,
        buffer: *mut VdoBuffer,
        error: *mut *mut GError,
    ) -> gboolean;
}
extern "C" {
    pub fn vdo_stream_get_buffer(self_: *mut VdoStream, error: *mut *mut GError) -> *mut VdoBuffer;
}
extern "C" {
    pub fn vdo_stream_to_fd(
        settings: *mut VdoMap,
        data_fd: ::std::os::raw::c_int,
        meta_fd: ::std::os::raw::c_int,
        error: *mut *mut GError,
    ) -> *mut VdoStream;
}
extern "C" {
    pub fn vdo_stream_snapshot(settings: *mut VdoMap, error: *mut *mut GError) -> *mut VdoBuffer;
}
extern "C" {
    pub fn vdo_stream_encode(
        self_: *mut VdoStream,
        in_buf: *mut *mut VdoBuffer,
        settings: *mut VdoMap,
        error: *mut *mut GError,
    ) -> gboolean;
}
extern "C" {
    pub fn vdo_stream_get_event(self_: *mut VdoStream, error: *mut *mut GError) -> *mut VdoMap;
}
pub const VDO_ERROR_NOT_FOUND: _bindgen_ty_24 = _bindgen_ty_24::VDO_ERROR_NOT_FOUND;
pub const VDO_ERROR_EXISTS: _bindgen_ty_24 = _bindgen_ty_24::VDO_ERROR_EXISTS;
pub const VDO_ERROR_INVALID_ARGUMENT: _bindgen_ty_24 = _bindgen_ty_24::VDO_ERROR_INVALID_ARGUMENT;
pub const VDO_ERROR_PERMISSION_DENIED: _bindgen_ty_24 = _bindgen_ty_24::VDO_ERROR_PERMISSION_DENIED;
pub const VDO_ERROR_NOT_SUPPORTED: _bindgen_ty_24 = _bindgen_ty_24::VDO_ERROR_NOT_SUPPORTED;
pub const VDO_ERROR_CLOSED: _bindgen_ty_24 = _bindgen_ty_24::VDO_ERROR_CLOSED;
pub const VDO_ERROR_BUSY: _bindgen_ty_24 = _bindgen_ty_24::VDO_ERROR_BUSY;
pub const VDO_ERROR_IO: _bindgen_ty_24 = _bindgen_ty_24::VDO_ERROR_IO;
pub const VDO_ERROR_HAL: _bindgen_ty_24 = _bindgen_ty_24::VDO_ERROR_HAL;
pub const VDO_ERROR_DBUS: _bindgen_ty_24 = _bindgen_ty_24::VDO_ERROR_DBUS;
pub const VDO_ERROR_OOM: _bindgen_ty_24 = _bindgen_ty_24::VDO_ERROR_OOM;
pub const VDO_ERROR_IDLE: _bindgen_ty_24 = _bindgen_ty_24::VDO_ERROR_IDLE;
pub const VDO_ERROR_NO_DATA: _bindgen_ty_24 = _bindgen_ty_24::VDO_ERROR_NO_DATA;
pub const VDO_ERROR_NO_BUFFER_SPACE: _bindgen_ty_24 = _bindgen_ty_24::VDO_ERROR_NO_BUFFER_SPACE;
pub const VDO_ERROR_BUFFER_FAILURE: _bindgen_ty_24 = _bindgen_ty_24::VDO_ERROR_BUFFER_FAILURE;
pub const VDO_ERROR_INTERFACE_DOWN: _bindgen_ty_24 = _bindgen_ty_24::VDO_ERROR_INTERFACE_DOWN;
pub const VDO_ERROR_FAILED: _bindgen_ty_24 = _bindgen_ty_24::VDO_ERROR_FAILED;
pub const VDO_ERROR_FATAL: _bindgen_ty_24 = _bindgen_ty_24::VDO_ERROR_FATAL;
pub const VDO_ERROR_NOT_CONTROLLED: _bindgen_ty_24 = _bindgen_ty_24::VDO_ERROR_NOT_CONTROLLED;
pub const VDO_ERROR_NO_EVENT: _bindgen_ty_24 = _bindgen_ty_24::VDO_ERROR_NO_EVENT;
pub const VDO_ERROR_NO_VIDEO: _bindgen_ty_24 = _bindgen_ty_24::VDO_ERROR_NO_VIDEO;
#[repr(u32)]
#[non_exhaustive]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _bindgen_ty_24 {
    VDO_ERROR_NOT_FOUND = 1,
    VDO_ERROR_EXISTS = 2,
    VDO_ERROR_INVALID_ARGUMENT = 3,
    VDO_ERROR_PERMISSION_DENIED = 4,
    VDO_ERROR_NOT_SUPPORTED = 5,
    VDO_ERROR_CLOSED = 6,
    VDO_ERROR_BUSY = 7,
    VDO_ERROR_IO = 8,
    VDO_ERROR_HAL = 9,
    VDO_ERROR_DBUS = 10,
    VDO_ERROR_OOM = 11,
    VDO_ERROR_IDLE = 12,
    VDO_ERROR_NO_DATA = 13,
    VDO_ERROR_NO_BUFFER_SPACE = 14,
    VDO_ERROR_BUFFER_FAILURE = 15,
    VDO_ERROR_INTERFACE_DOWN = 16,
    VDO_ERROR_FAILED = 17,
    VDO_ERROR_FATAL = 18,
    VDO_ERROR_NOT_CONTROLLED = 19,
    VDO_ERROR_NO_EVENT = 20,
    VDO_ERROR_NO_VIDEO = 21,
}
extern "C" {
    pub fn vdo_error_quark() -> GQuark;
}
extern "C" {
    pub fn vdo_error_is_expected(error: *mut *mut GError) -> gboolean;
}
extern "C" {
    pub fn vdo_error_is_resource_limitation(error: *mut *mut GError) -> gboolean;
}
